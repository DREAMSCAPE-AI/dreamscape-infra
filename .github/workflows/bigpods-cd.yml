name: ğŸš€ DreamScape Big Pods - Continuous Deployment

on:
  push:
    branches: [main]
    tags: ['v*']
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target Environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      version:
        description: 'Version to deploy (optional)'
        required: false
        type: string
      deployment_strategy:
        description: 'Deployment Strategy'
        required: true
        default: 'rolling'
        type: choice
        options:
          - rolling
          - blue-green
          - canary
      force_deployment:
        description: 'Force deployment (skip validations)'
        required: false
        default: false
        type: boolean

# Prevent concurrent deployments
concurrency:
  group: deployment-${{ github.ref }}
  cancel-in-progress: false

env:
  # Deployment Configuration
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1
  DEPLOYMENT_TIMEOUT: 1800

  # Registry Configuration
  REGISTRY_URL: ghcr.io
  REGISTRY_NAMESPACE: dreamscape-ai

  # Tooling
  KUBECTL_FALLBACK_VERSION: v1.30.4

  # Monitoring Configuration
  MONITORING_ENABLED: true
  HEALTH_CHECK_TIMEOUT: 300

jobs:
  # ============================================================================
  # Pre-deployment: Validation and preparation
  # ============================================================================
  pre-deployment:
    name: ğŸ” Pre-deployment Validation
    runs-on: ubuntu-latest
    timeout-minutes: 10

    outputs:
      deployment-version: ${{ steps.version.outputs.version }}
      target-environment: ${{ steps.environment.outputs.environment }}
      deployment-strategy: ${{ steps.strategy.outputs.strategy }}
      should-deploy: ${{ steps.validation.outputs.should-deploy }}

    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ¯ Determine Target Environment
        id: environment
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
          fi

      - name: ğŸ·ï¸ Determine Deployment Version
        id: version
        run: |
          if [[ "${{ inputs.version }}" != "" ]]; then
            version="${{ inputs.version }}"
          elif [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            version="${{ github.ref_name }}"
          else
            version="$(git rev-parse --short HEAD)"
          fi

          echo "version=$version" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Deployment version: $version"

      - name: ğŸ¯ Determine Deployment Strategy
        id: strategy
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "strategy=${{ inputs.deployment_strategy }}" >> $GITHUB_OUTPUT
          elif [[ "${{ steps.environment.outputs.environment }}" == "production" ]]; then
            echo "strategy=blue-green" >> $GITHUB_OUTPUT
          else
            echo "strategy=rolling" >> $GITHUB_OUTPUT
          fi

      - name: âœ… Validate Deployment Prerequisites
        id: validation
        run: |
          echo "ğŸ” Validating deployment prerequisites..."

          target_env="${{ steps.environment.outputs.environment }}"
          version="${{ steps.version.outputs.version }}"

          # Check if this is a valid deployment
          should_deploy="true"

          # Production validations
          if [[ "$target_env" == "production" ]]; then
            # Must be a tag for production
            if [[ "${{ github.ref }}" != refs/tags/v* ]] && [[ "${{ inputs.force_deployment }}" != "true" ]]; then
              echo "âŒ Production deployments require version tags"
              should_deploy="false"
            fi

            # Version must follow semver
            if [[ ! "$version" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]] && [[ "${{ inputs.force_deployment }}" != "true" ]]; then
              echo "âŒ Production version must follow semantic versioning (v1.2.3)"
              should_deploy="false"
            fi
          fi

          echo "should-deploy=$should_deploy" >> $GITHUB_OUTPUT

          if [[ "$should_deploy" == "true" ]]; then
            echo "âœ… Prerequisites validated"
            echo "ğŸ¯ Environment: $target_env"
            echo "ğŸ“¦ Version: $version"
            echo "ğŸš€ Strategy: ${{ steps.strategy.outputs.strategy }}"
          else
            echo "âŒ Prerequisites validation failed"
            exit 1
          fi

  # ============================================================================
  # Build and Push: Build images and push to registry
  # ============================================================================
  build-and-push:
    name: ğŸ—ï¸ Build & Push Images
    runs-on: ubuntu-latest
    needs: pre-deployment
    if: needs.pre-deployment.outputs.should-deploy == 'true'
    timeout-minutes: 30
    env:
      BIGPODS_COMPOSE_FILE: docker-compose.bigpods.prod.yml

    strategy:
      matrix:
        pod: [core, business, experience]
      fail-fast: false

    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: Checkout build dependencies
        run: |
          if [[ ! -d ../dreamscape-services ]]; then
            git clone --depth 1 https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/DREAMSCAPE-AI/dreamscape-services.git ../dreamscape-services
          fi

          if [[ ! -d ../dreamscape-frontend ]]; then
            git clone --depth 1 https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/DREAMSCAPE-AI/dreamscape-frontend.git ../dreamscape-frontend
          fi

      - name: Ensure bigpods scripts executable
        run: |
          find scripts/bigpods -name "*.sh" -type f -exec chmod +x {} \;

      - name: ğŸ³ Setup Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/arm64

      - name: ğŸ” Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY_URL }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ—ï¸ Build ${{ matrix.pod }} Pod
        working-directory: scripts/bigpods
        timeout-minutes: 20
        run: |
          echo "ğŸ—ï¸ Building ${{ matrix.pod }} pod..."

          version="${{ needs.pre-deployment.outputs.deployment-version }}"

          # Build with version tag
          ./build-bigpods.sh \
            -v "$version" \
            --push \
            --verbose \
            ${{ matrix.pod }}

      - name: ğŸ” Verify Image Push
        run: |
          echo "ğŸ” Verifying pushed image..."
          version="${{ needs.pre-deployment.outputs.deployment-version }}"
          image="${{ env.REGISTRY_URL }}/${{ env.REGISTRY_NAMESPACE }}/${{ matrix.pod }}-pod:$version"

          if docker manifest inspect "$image" >/dev/null 2>&1; then
            echo "âœ… Image successfully pushed: $image"
          else
            echo "âŒ Image verification failed: $image"
            exit 1
          fi

  # ============================================================================
  # Deploy to Staging: Always deploy to staging first
  # ============================================================================
  deploy-staging:
    name: ğŸš€ Deploy to Staging
    runs-on: ubuntu-latest
    needs: [pre-deployment, build-and-push]
    if: needs.pre-deployment.outputs.should-deploy == 'true'
    timeout-minutes: 20
    environment: staging

    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: Ensure bigpods scripts executable
        run: |
          find scripts/bigpods -name "*.sh" -type f -exec chmod +x {} \;

      - name: ğŸ” Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY_URL }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ”§ Setup Deployment Environment
        run: |
          set -euo pipefail
          echo "ğŸ”§ Setting up staging deployment environment..."

          kubectl_version="${KUBECTL_VERSION:-}"
          if [[ -z "$kubectl_version" ]]; then
            kubectl_version="$(curl -fsSL https://dl.k8s.io/release/stable.txt || true)"
          fi

          if [[ -z "$kubectl_version" ]]; then
            echo "::warning::Unable to resolve kubectl version from stable.txt, falling back to ${KUBECTL_FALLBACK_VERSION}"
            kubectl_version="${KUBECTL_FALLBACK_VERSION}"
          fi

          echo "ğŸ“¦ Installing kubectl ${kubectl_version}..."
          curl -fsSLo kubectl "https://dl.k8s.io/release/${kubectl_version}/bin/linux/amd64/kubectl"
          curl -fsSLo kubectl.sha256 "https://dl.k8s.io/release/${kubectl_version}/bin/linux/amd64/kubectl.sha256"

          if ! echo "$(cat kubectl.sha256)  kubectl" | sha256sum --check --status; then
            echo "::error::kubectl checksum verification failed"
            exit 1
          fi

          sudo install -m 0755 kubectl /usr/local/bin/kubectl
          kubectl version --client --output=yaml

      - name: ğŸ”‘ Configure Kubernetes Access
        env:
          K3S_HOST: ${{ secrets.K3S_HOST }}
          K3S_SSH_KEY: ${{ secrets.K3S_SSH_KEY }}
        run: |
          echo "ğŸ”‘ Configuring kubeconfig for K3s via SSH tunnel..."

          if [[ -z "$K3S_HOST" || -z "$K3S_SSH_KEY" ]]; then
            echo "::error::K3S_HOST/K3S_SSH_KEY secrets are required for Kubernetes access"
            exit 1
          fi

          mkdir -p ~/.ssh ~/.kube
          echo "$K3S_SSH_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H "$K3S_HOST" >> ~/.ssh/known_hosts

          LOCAL_API_PORT=7443

          # Fetch kubeconfig from the remote K3s server
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o ConnectTimeout=10 ubuntu@"$K3S_HOST" \
            "sudo cat /etc/rancher/k3s/k3s.yaml" > ~/.kube/config

          # Point kubeconfig to the local forwarded port
          sed -i "s|127.0.0.1:6443|127.0.0.1:${LOCAL_API_PORT}|g" ~/.kube/config

          # Start SSH tunnel to the K3s API server
          ssh -i ~/.ssh/id_rsa \
            -o StrictHostKeyChecking=no \
            -o ExitOnForwardFailure=yes \
            -o ServerAliveInterval=30 \
            -o ServerAliveCountMax=3 \
            -f -N -L ${LOCAL_API_PORT}:127.0.0.1:6443 \
            ubuntu@"$K3S_HOST"

          echo "KUBECONFIG=$HOME/.kube/config" >> $GITHUB_ENV
          echo "K3S_TUNNEL_PORT=${LOCAL_API_PORT}" >> $GITHUB_ENV

          # Verify connectivity with retries to avoid transient tunnel failures
          success=false
          for attempt in {1..5}; do
            if kubectl cluster-info >/dev/null 2>&1; then
              kubectl cluster-info
              success=true
              break
            fi

            echo "Waiting for Kubernetes API via SSH tunnel (attempt $attempt/5)..."
            sleep 5
          done

          if [[ "$success" != "true" ]]; then
            echo "::error::Unable to reach Kubernetes API via SSH tunnel"
            exit 1
          fi

      - name: ğŸ“¦ Bootstrap staging k8s resources
        run: |
          kubectl apply -f k8s/bigpods-staging-bootstrap.yaml

      - name: ğŸš€ Deploy to Staging
        working-directory: scripts/bigpods
        timeout-minutes: 15
        run: |
          echo "ğŸš€ Deploying to staging environment..."

          version="${{ needs.pre-deployment.outputs.deployment-version }}"
          strategy="${{ needs.pre-deployment.outputs.deployment-strategy }}"

          # Configure staging deployment
          case "$strategy" in
            "rolling")
              deployment_args="--rolling"
              ;;
            "blue-green")
              deployment_args="--blue-green"
              ;;
            "canary")
              deployment_args="--canary --canary-percent 20"
              ;;
          esac

          # Execute deployment
          ./deploy-bigpods.sh \
            --env staging \
            --version "$version" \
            $deployment_args \
            --force \
            --verbose

      - name: âœ… Deployment Complete
        run: |
          echo "âœ… Staging deployment completed successfully"

  # ============================================================================
  # Deploy to Production: Only if targeting production
  # ============================================================================
  deploy-production:
    name: ğŸ­ Deploy to Production
    runs-on: ubuntu-latest
    needs: [pre-deployment, build-and-push, deploy-staging]
    if: |
      needs.pre-deployment.outputs.should-deploy == 'true' &&
      (needs.pre-deployment.outputs.target-environment == 'production' ||
       startsWith(github.ref, 'refs/tags/v'))
    timeout-minutes: 30
    environment: production

    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: Ensure bigpods scripts executable
        run: |
          find scripts/bigpods -name "*.sh" -type f -exec chmod +x {} \;

      - name: ğŸ” Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY_URL }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ”§ Setup Production Environment
        run: |
          set -euo pipefail
          echo "ğŸ”§ Setting up production deployment environment..."

          kubectl_version="${KUBECTL_VERSION:-}"
          if [[ -z "$kubectl_version" ]]; then
            kubectl_version="$(curl -fsSL https://dl.k8s.io/release/stable.txt || true)"
          fi

          if [[ -z "$kubectl_version" ]]; then
            echo "::warning::Unable to resolve kubectl version from stable.txt, falling back to ${KUBECTL_FALLBACK_VERSION}"
            kubectl_version="${KUBECTL_FALLBACK_VERSION}"
          fi

          echo "ğŸ“¦ Installing kubectl ${kubectl_version}..."
          curl -fsSLo kubectl "https://dl.k8s.io/release/${kubectl_version}/bin/linux/amd64/kubectl"
          curl -fsSLo kubectl.sha256 "https://dl.k8s.io/release/${kubectl_version}/bin/linux/amd64/kubectl.sha256"

          if ! echo "$(cat kubectl.sha256)  kubectl" | sha256sum --check --status; then
            echo "::error::kubectl checksum verification failed"
            exit 1
          fi

          sudo install -m 0755 kubectl /usr/local/bin/kubectl
          kubectl version --client --output=yaml

      - name: ğŸ”‘ Configure Kubernetes Access
        env:
          K3S_HOST: ${{ secrets.K3S_HOST }}
          K3S_SSH_KEY: ${{ secrets.K3S_SSH_KEY }}
        run: |
          echo "ğŸ”‘ Configuring kubeconfig for K3s via SSH tunnel..."

          if [[ -z "$K3S_HOST" || -z "$K3S_SSH_KEY" ]]; then
            echo "::error::K3S_HOST/K3S_SSH_KEY secrets are required for Kubernetes access"
            exit 1
          fi

          mkdir -p ~/.ssh ~/.kube
          echo "$K3S_SSH_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H "$K3S_HOST" >> ~/.ssh/known_hosts

          LOCAL_API_PORT=7443

          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o ConnectTimeout=10 ubuntu@"$K3S_HOST" \
            "sudo cat /etc/rancher/k3s/k3s.yaml" > ~/.kube/config

          # Point kubeconfig to the local forwarded port
          sed -i "s|127.0.0.1:6443|127.0.0.1:${LOCAL_API_PORT}|g" ~/.kube/config

          # Start SSH tunnel to the K3s API server
          ssh -i ~/.ssh/id_rsa \
            -o StrictHostKeyChecking=no \
            -o ExitOnForwardFailure=yes \
            -o ServerAliveInterval=30 \
            -o ServerAliveCountMax=3 \
            -f -N -L ${LOCAL_API_PORT}:127.0.0.1:6443 \
            ubuntu@"$K3S_HOST"

          echo "KUBECONFIG=$HOME/.kube/config" >> $GITHUB_ENV
          echo "K3S_TUNNEL_PORT=${LOCAL_API_PORT}" >> $GITHUB_ENV

          success=false
          for attempt in {1..5}; do
            if kubectl cluster-info >/dev/null 2>&1; then
              kubectl cluster-info
              success=true
              break
            fi

            echo "Waiting for Kubernetes API via SSH tunnel (attempt $attempt/5)..."
            sleep 5
          done

          if [[ "$success" != "true" ]]; then
            echo "::error::Unable to reach Kubernetes API via SSH tunnel"
            exit 1
          fi

      - name: âœ… Pre-production Ready
        run: |
          echo "âœ… Ready for production deployment"

      - name: ğŸ’¾ Backup Production
        working-directory: scripts/bigpods
        timeout-minutes: 10
        run: |
          echo "ğŸ’¾ Creating production backup before deployment..."

          ./backup-bigpods.sh \
            --type configs \
            --s3-bucket dreamscape-production-backups \
            --env production \
            --force

      - name: ğŸš€ Deploy to Production
        working-directory: scripts/bigpods
        timeout-minutes: 20
        run: |
          echo "ğŸš€ Deploying to production environment..."

          version="${{ needs.pre-deployment.outputs.deployment-version }}"
          strategy="${{ needs.pre-deployment.outputs.deployment-strategy }}"

          # Configure production deployment
          case "$strategy" in
            "rolling")
              deployment_args="--rolling"
              ;;
            "blue-green")
              deployment_args="--blue-green"
              ;;
            "canary")
              deployment_args="--canary --canary-percent 10"
              ;;
          esac

          # Execute deployment with notifications
          ./deploy-bigpods.sh \
            --env production \
            --version "$version" \
            $deployment_args \
            --notify \
            --slack-webhook "${{ secrets.SLACK_WEBHOOK_URL }}" \
            --force \
            --verbose

      - name: âœ… Production Deployment Complete
        run: |
          echo "âœ… Production deployment completed successfully"

  # ============================================================================
  # Post-deployment: Validation and monitoring
  # ============================================================================
  post-deployment:
    name: ğŸ“Š Post-deployment Validation
    runs-on: ubuntu-latest
    needs: [pre-deployment, deploy-staging, deploy-production]
    if: always() && needs.pre-deployment.outputs.should-deploy == 'true'
    timeout-minutes: 15

    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ğŸ“Š Deployment Summary
        run: |
          echo "ğŸ“Š DreamScape Big Pods Deployment Summary"
          echo "========================================"
          echo ""
          echo "ğŸ¯ Target Environment: ${{ needs.pre-deployment.outputs.target-environment }}"
          echo "ğŸ“¦ Version: ${{ needs.pre-deployment.outputs.deployment-version }}"
          echo "ğŸš€ Strategy: ${{ needs.pre-deployment.outputs.deployment-strategy }}"
          echo ""
          echo "ğŸ“‹ Deployment Results:"
          echo "ğŸš€ Staging: ${{ needs.deploy-staging.result }}"

          if [[ "${{ needs.deploy-production.result }}" != "" ]]; then
            echo "ğŸ­ Production: ${{ needs.deploy-production.result }}"
          fi

      - name: ğŸ“§ Send Deployment Notification
        if: always()
        run: |
          echo "ğŸ“§ Sending deployment notification..."

          if [[ "${{ needs.deploy-staging.result }}" == "success" ]]; then
            if [[ "${{ needs.deploy-production.result }}" == "success" ]] || [[ "${{ needs.deploy-production.result }}" == "" ]]; then
              echo "âœ… Deployment completed successfully!"
              status="success"
            else
              echo "âš ï¸ Production deployment failed, but staging succeeded"
              status="warning"
            fi
          else
            echo "âŒ Deployment failed"
            status="failure"
          fi

          # Store status for potential webhooks
          echo "DEPLOYMENT_STATUS=$status" >> $GITHUB_ENV

      - name: ğŸ§¹ Cleanup Old Images
        if: success()
        run: |
          echo "ğŸ§¹ Cleaning up old container images..."

          # Keep last 5 versions
          version="${{ needs.pre-deployment.outputs.deployment-version }}"

          # This would integrate with actual registry cleanup
          echo "ğŸ§¹ Cleanup would remove images older than 5 versions"
          echo "ğŸ“¦ Current version: $version"

  # ============================================================================
  # Rollback: Emergency rollback capability
  # ============================================================================
  emergency-rollback:
    name: ğŸ†˜ Emergency Rollback
    runs-on: ubuntu-latest
    if: failure() && (needs.deploy-production.result == 'failure')
    needs: [pre-deployment, deploy-production]
    timeout-minutes: 15
    environment: production

    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: Ensure bigpods scripts executable
        run: |
          find scripts/bigpods -name "*.sh" -type f -exec chmod +x {} \;

      - name: ğŸ†˜ Execute Emergency Rollback
        working-directory: scripts/bigpods
        run: |
          echo "ğŸ†˜ Executing emergency rollback..."

          ./deploy-bigpods.sh \
            --env production \
            --rollback \
            --force \
            --notify \
            --slack-webhook "${{ secrets.SLACK_WEBHOOK_URL }}"

      - name: âœ… Rollback Complete
        run: |
          echo "âœ… Rollback completed successfully"

# ============================================================================
# Workflow Status and Notifications
# ============================================================================
  workflow-status:
    name: ğŸ“¢ Workflow Status
    runs-on: ubuntu-latest
    needs: [post-deployment, emergency-rollback]
    if: always()

    steps:
      - name: ğŸ“¢ Final Status Report
        run: |
          echo "ğŸ“¢ DreamScape Big Pods CD - Final Status"
          echo "======================================"

          if [[ "${{ needs.post-deployment.result }}" == "success" ]]; then
            echo "ğŸ‰ Deployment workflow completed successfully!"
            echo "âœ… All services deployed and validated"
          elif [[ "${{ needs.emergency-rollback.result }}" == "success" ]]; then
            echo "ğŸ”„ Deployment failed but rollback successful"
            echo "âš ï¸ Please investigate deployment issues"
          else
            echo "âŒ Deployment workflow failed"
            echo "ğŸ†˜ Manual intervention may be required"
          fi
