name: Simple SSH Deploy

on:
  push:
    branches: [main, DR-51-US-INFRA-002.3---Configuration-du-déploiement]
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment"
        required: true
        default: "staging"
        type: choice
        options:
          - dev
          - staging
          - production
      service:
        description: "Service"
        required: true
        default: "frontend"
        type: choice
        options:
          - frontend
          - backend
          - both

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup and Deploy
        run: |
          # Définir les variables
          ENV="${{ github.event.inputs.environment || 'staging' }}"
          SERVICE="${{ github.event.inputs.service || 'frontend' }}"
          
          echo "Deploying $SERVICE to $ENV"
          
          # Choisir host et clé selon l'environnement
          case "$ENV" in
            "production")
              HOST="${{ secrets.VM_HOST_PRODUCTION }}"
              SSH_KEY="${{ secrets.SSH_PRIVATE_KEY_PRODUCTION }}"
              ;;
            "staging")
              HOST="${{ secrets.VM_HOST_STAGING }}"
              SSH_KEY="${{ secrets.SSH_PRIVATE_KEY_STAGING }}"
              ;;
            "dev")
              HOST="${{ secrets.VM_HOST_DEV }}"
              SSH_KEY="${{ secrets.SSH_PRIVATE_KEY_DEV }}"
              ;;
          esac
          
          # Créer la clé SSH
          mkdir -p ~/.ssh
          echo "$SSH_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Ajouter l'host aux known_hosts
          ssh-keyscan -H "$HOST" >> ~/.ssh/known_hosts
          
          # Fonction de déploiement
          deploy_service() {
            local service=$1
            echo "Deploying $service..."
            
            ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ubuntu@$HOST << EOF
              echo "Stopping existing $service container..."
              docker stop dreamscape-$service-$ENV 2>/dev/null || true
              docker rm dreamscape-$service-$ENV 2>/dev/null || true
              
              echo "Pulling new $service image..."
              docker pull dreamscape/$service:latest
              
              echo "Starting new $service container..."
              if [ "$service" = "frontend" ]; then
                docker run -d \
                  --name dreamscape-$service-$ENV \
                  --restart unless-stopped \
                  -p 80:80 \
                  -e NODE_ENV=$ENV \
                  dreamscape/$service:latest
              else
                docker run -d \
                  --name dreamscape-$service-$ENV \
                  --restart unless-stopped \
                  -p 8080:8080 \
                  -e NODE_ENV=$ENV \
                  dreamscape/$service:latest
              fi
              
              echo "Checking $service container..."
              sleep 10
              if docker ps | grep dreamscape-$service-$ENV; then
                echo "$service deployed successfully"
              else
                echo "$service deployment failed"
                exit 1
              fi
          EOF
          }
          
          # Déployer selon le service choisi
          if [ "$SERVICE" = "frontend" ] || [ "$SERVICE" = "both" ]; then
            deploy_service "frontend"
          fi
          
          if [ "$SERVICE" = "backend" ] || [ "$SERVICE" = "both" ]; then
            deploy_service "backend"
          fi
          
          echo "Deployment completed!"
          
          # Cleanup
          rm -f ~/.ssh/deploy_key